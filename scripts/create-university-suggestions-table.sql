-- Create custom types for roles and permissions
CREATE TYPE public.app_role AS ENUM ('admin', 'moderator', 'user');
CREATE TYPE public.app_permission AS ENUM (
  'universities.create',
  'universities.update',
  'universities.delete',
  'university_suggestions.approve',
  'university_suggestions.reject',
  'university_suggestions.view'
);

-- Create user_roles table to track user roles
CREATE TABLE IF NOT EXISTS public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL,
  UNIQUE (user_id, role)
);
COMMENT ON TABLE public.user_roles IS 'Application roles for each user';

-- Create role_permissions table to define which roles have which permissions
CREATE TABLE IF NOT EXISTS public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role app_role NOT NULL,
  permission app_permission NOT NULL,
  UNIQUE (role, permission)
);
COMMENT ON TABLE public.role_permissions IS 'Application permissions for each role';

-- Insert initial roles and permissions
INSERT INTO public.role_permissions (role, permission)
VALUES 
  ('admin', 'universities.create'),
  ('admin', 'universities.update'),
  ('admin', 'universities.delete'),
  ('admin', 'university_suggestions.approve'),
  ('admin', 'university_suggestions.reject'),
  ('admin', 'university_suggestions.view'),
  ('moderator', 'university_suggestions.view'),
  ('moderator', 'university_suggestions.approve'),
  ('moderator', 'university_suggestions.reject');

-- Create the authorization function to check permissions
CREATE OR REPLACE FUNCTION public.authorize(requested_permission app_permission)
RETURNS BOOLEAN AS $$
DECLARE
  bind_permissions INT;
  user_role public.app_role;
BEGIN
  -- Get the user's role from JWT
  SELECT 
    (auth.jwt() ->> 'user_role')::public.app_role 
  INTO user_role;
  
  -- Count permissions that match the requested permission for this role
  SELECT
    COUNT(*)
  INTO
    bind_permissions
  FROM
    public.role_permissions
  WHERE
    role_permissions.permission = requested_permission
    AND role_permissions.role = user_role;
    
  -- Return true if the user has the permission
  RETURN bind_permissions > 0;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';

-- Create the auth hook function to set custom claims
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB LANGUAGE plpgsql STABLE AS $$
DECLARE
  claims JSONB;
  user_role public.app_role;
BEGIN
  -- Fetch the user role from the user_roles table
  SELECT
    role
  INTO
    user_role
  FROM
    public.user_roles
  WHERE
    user_id = (event ->> 'user_id')::UUID;
  
  claims := event -> 'claims';
  
  -- Set the claim if user has a role
  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  ELSE
    -- Default to 'user' role if not specified
    claims := jsonb_set(claims, '{user_role}', '"user"');
  END IF;
  
  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);
  
  -- Return the modified event
  RETURN event;
END;
$$;

-- Grant necessary permissions for the auth hook
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;
GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;
REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;
CREATE POLICY "Allow auth admin to read user roles" ON public.user_roles AS permissive FOR SELECT TO supabase_auth_admin USING (true);

-- Create university_suggestions table
CREATE TABLE IF NOT EXISTS public.university_suggestions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  city TEXT,
  country_id UUID NOT NULL REFERENCES public.countries(id),
  website TEXT,
  submitter_email TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  reviewed_at TIMESTAMP WITH TIME ZONE,
  reviewed_by UUID REFERENCES auth.users(id),
  notes TEXT
);

-- Add RLS policies
ALTER TABLE public.university_suggestions ENABLE ROW LEVEL SECURITY;

-- Policy to allow anyone to insert
CREATE POLICY "Anyone can suggest a university" ON public.university_suggestions
  FOR INSERT
  WITH CHECK (true);

-- Policy to allow view access based on permissions
CREATE POLICY "Users with view permission can view suggestions" ON public.university_suggestions
  FOR SELECT
  USING ((SELECT authorize('university_suggestions.view')));

-- Policies for approve/reject based on permissions
CREATE POLICY "Users with approve permission can update suggestions" ON public.university_suggestions
  FOR UPDATE
  USING ((SELECT authorize('university_suggestions.approve')));

-- Create trigger to update the updated_at timestamp
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_university_suggestions_modtime
  BEFORE UPDATE ON public.university_suggestions
  FOR EACH ROW
  EXECUTE FUNCTION update_modified_column();

-- Add comment to table
COMMENT ON TABLE public.university_suggestions IS 'Stores user-submitted university suggestions for review';